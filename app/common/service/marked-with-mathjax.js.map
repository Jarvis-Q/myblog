{
    "version": 3,
    "sources": [
        "../../../src/common/service/marked-with-mathjax.js"
    ],
    "names": [
        "content",
        "config",
        "MathJax",
        "start",
        "typeset",
        "math",
        "format",
        "svg",
        "data",
        "resolve",
        "_renderMathJax",
        "text",
        "reg",
        "cap",
        "lastIndex",
        "exec",
        "strStart",
        "index",
        "strEnd",
        "length",
        "mathContent",
        "substring",
        "_mathSpanRender",
        "mathLexer",
        "Lexer",
        "tokens",
        "lex",
        "i",
        "item",
        "type",
        "lang",
        "Parser",
        "parse",
        "render"
    ],
    "mappings": ";;;;;;;;;;;;;;;;AAGA;;;;;;;wEAMA,iBAA8BA,OAA9B;AAAA;AAAA;AAAA;AAAA;AACE,kCAAQC,MAAR,CAAe;AACbC,uBAAS;AADI,aAAf;AAGA,kCAAQC,KAAR;;AAJF;AAAA,mBAMe,sBAAY,mBAAW;AAClC,oCAAQC,OAAR,CAAgB;AACdC,sBAAML,OADQ;AAEdM,wBAAQ,KAFM;AAGdC,qBAAK;AAHS,eAAhB,EAIG,UAAUC,IAAV,EAAgB;AACjBC,wBAAQD,KAAKD,GAAb;AACD,eAND;AAOD,aARY,CANf;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;kBAAeG,c;;;;;AAkBf;;;;;;;;yEAKA,kBAA+BC,IAA/B;AAAA;AAAA;AAAA;AAAA;AAAA;AACQC,eADR,GACc,cADd;AAEMC,eAFN;;;AAIED,gBAAIE,SAAJ,GAAgB,CAAhB;;AAJF;AAAA,iBAMSH,IANT;AAAA;AAAA;AAAA;;AAOIE,kBAAMD,IAAIG,IAAJ,CAASJ,IAAT,CAAN;;AAPJ,iBAQQE,GARR;AAAA;AAAA;AAAA;;AASYG,oBATZ,GASuBH,IAAII,KAT3B;AAUYC,kBAVZ,GAUqBL,IAAII,KAAJ,GAAYJ,IAAI,CAAJ,EAAOM,MAVxC;AAAA;AAAA,mBAWgCT,eAAeG,IAAI,CAAJ,CAAf,CAXhC;;AAAA;AAWYO,uBAXZ;;;AAaMT,mBAAOA,KAAKU,SAAL,CAAe,CAAf,EAAkBL,QAAlB,IAA8BI,WAA9B,GAA4CT,KAAKU,SAAL,CAAeH,MAAf,CAAnD;AACAN,gBAAIE,SAAJ,IAAiBM,YAAYD,MAA7B;;AAdN;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA,8CAqBSR,IArBT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;kBAAeW,e;;;;;AAyBf;;;;;;;;AAzDA;;;;AACA;;;;;;;yEA8De,kBAAsBtB,OAAtB;AAAA;AAAA;AAAA;AAAA;AAAA;AACTuB,qBADS,GACG,IAAI,iBAAOC,KAAX,EADH;AAETC,kBAFS,GAEAF,UAAUG,GAAV,CAAc1B,OAAd,CAFA;AAIJ2B,aAJI,GAIA,CAJA;;AAAA;AAAA,kBAIGA,IAAIF,OAAON,MAJd;AAAA;AAAA;AAAA;;AAKLS,gBALK,GAKEH,OAAOE,CAAP,CALF;;AAOX;;AAPW,kBAQPC,KAAKC,IAAL,KAAc,MAAd,IAAwBD,KAAKE,IAAL,KAAc,MAR/B;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAWKpB,eAAekB,KAAKjB,IAApB,CAXL;;AAAA;AAAA;AASTc,mBAAOE,CAAP,CATS;AAUPE,kBAVO,EAUD,WAVC;AAWPlB,kBAXO;AAAA;;AAAA;AAAA,iBAgBPiB,KAAKjB,IAhBE;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAiBSW,gBAAgBM,KAAKjB,IAArB,CAjBT;;AAAA;AAiBTiB,iBAAKjB,IAjBI;;AAAA;AAIsBgB,eAJtB;AAAA;AAAA;;AAAA;AAAA,8CAqBN,iBAAOI,MAAP,CAAcC,KAAd,CAAoBP,MAApB,CArBM;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;WAAeQ,M;;;;SAAAA,M",
    "file": "../../../src/common/service/marked-with-mathjax.js",
    "sourcesContent": [
        "import mathJax from 'mathjax-node';\nimport marked from 'marked';\n\n/**\n * 渲染具体的 MathJax 表达式\n *\n * @param content\n * @returns {Promise.<*>}\n */\nasync function _renderMathJax(content) {\n  mathJax.config({\n    MathJax: {}\n  });\n  mathJax.start();\n\n  return await new Promise(resolve => {\n    mathJax.typeset({\n      math: content,\n      format: 'TeX',\n      svg: true,\n    }, function (data) {\n      resolve(data.svg);\n    });\n  });\n}\n\n\n/**\n * 渲染行内数学表达式\n * @param text\n * @returns {Promise.<*>}\n */\nasync function _mathSpanRender(text) {\n  const reg = /`\\$(.*?)\\$`/g;\n  let cap;\n\n  reg.lastIndex = 0;\n\n  while (text) {\n    cap = reg.exec(text);\n    if (cap) {\n      const strStart = cap.index;\n      const strEnd = cap.index + cap[0].length;\n      const mathContent = await _renderMathJax(cap[1]);\n\n      text = text.substring(0, strStart) + mathContent + text.substring(strEnd);\n      reg.lastIndex += mathContent.length;\n\n    } else {\n      break;\n    }\n  }\n\n  return text;\n}\n\n\n/**\n * 渲染 Markdown 文本\n *\n * @param content\n * @returns {Promise.<void>}\n */\nexport default async function render(content) {\n  var mathLexer = new marked.Lexer();\n  var tokens = mathLexer.lex(content);\n\n  for (let i = 0; i < tokens.length; i++) {\n    const item = tokens[i];\n\n    // 处理块级表达式\n    if (item.type === 'code' && item.lang === 'math') {\n      tokens[i] = {\n        type: 'paragraph',\n        text: await _renderMathJax(item.text),\n      }\n    }\n\n    // 处理行内表达式\n    if (item.text) {\n      item.text = await _mathSpanRender(item.text);\n    }\n  }\n\n  return marked.Parser.parse(tokens);\n}\n"
    ]
}